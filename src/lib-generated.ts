export const files = [{"filename":"node_modules/@types/typed-cli/index.d.ts","content":"export { cli, option, configure } from './src/parser';\nexport { defaultHelpDecorator as plainDecorator, fancyHelpDecorator as fancyDecorator } from './src/printer';\nexport declare const chalkInstance: import(\"chalk\").Chalk & {\n    supportsColor: import(\"chalk\").ColorSupport;\n};\n"},{"filename":"node_modules/@types/typed-cli/pg/index.d.ts","content":"export {};\n"},{"filename":"node_modules/@types/typed-cli/presets/host.d.ts","content":""},{"filename":"node_modules/@types/typed-cli/presets/url.d.ts","content":"/// <reference types=\"node\" />\nimport url from 'url';\ndeclare const urlOption: import(\"../src/option\").Option<\"string\", false, false, url.UrlWithStringQuery>;\nexport default urlOption;\n"},{"filename":"node_modules/@types/typed-cli/src/index.d.ts","content":"export {};\n"},{"filename":"node_modules/@types/typed-cli/src/option.d.ts","content":"import { Validator, Preprocessor, BooleanValidator } from './pipeline';\ndeclare type TypeMap = {\n    number: number;\n    int: number;\n    string: string;\n    boolean: boolean;\n    any: number | string | boolean;\n};\nexport declare type Types = keyof TypeMap;\nexport declare type ResolveType<T extends Types> = TypeMap[T];\ndeclare const optionDataKey: unique symbol;\nexport declare type OptData<T> = {\n    type: Types;\n    labelName: string;\n    description: string;\n    isRequired: boolean;\n    aliases: string[];\n    isArray: boolean;\n    defaultValue?: T;\n    validators: Validator<any>[];\n    prePreprocessors: Preprocessor[];\n    postPreprocessors: Preprocessor[];\n};\nexport declare function getOptData(opt: Option<any, any, any, any>): OptData<any>;\nexport declare function setOptData(opt: Option<any, any, any, any>, data: OptData<any>): void;\nexport declare function cloneOption<O extends Option<any, any, any, any>>(opt: O): O;\nexport declare function updateOptData<O extends Option<any, any, any, any>>(opt: O, data: Partial<OptData<any>>): O;\nexport declare function changeOptData<O extends Option<any, any, any, any>>(opt: O, data: Partial<OptData<any>>): O;\nexport declare class Option<T extends Types, R extends boolean, A extends boolean, RT> {\n    name: string;\n    [optionDataKey]: OptData<RT>;\n    private _isRequired;\n    private _isArray;\n    constructor(type: T);\n    label(name: string): Option<T, R, A, RT>;\n    alias(...aliases: string[]): Option<T, R, A, RT>;\n    description(text: string): Option<T, R, A, RT>;\n    required(): Option<T, true, A, RT>;\n    array(): Option<T, R, true, RT>;\n    default(value: RT): Option<T, true, A, RT>;\n    validate(errorMsg: string, validator: BooleanValidator<T>): Option<T, R, A, RT>;\n    validate(validator: Validator<T>): Option<T, R, A, RT>;\n    process(phase: 'pre', fn: Preprocessor<any, ResolveType<T>>): Option<T, R, A, RT>;\n    process<FR>(phase: 'post', fn: Preprocessor<ResolveType<T>, FR>): Option<T, R, A, FR>;\n}\nexport declare type OptionSet = Record<string, Option<any, boolean, boolean, any>>;\nexport {};\n"},{"filename":"node_modules/@types/typed-cli/src/parser.d.ts","content":"import { Option, Types } from './option';\nimport { CliDeclaration, ResolveCliDeclaration } from './type-logic';\nimport { Writer, HelpDecorator } from './printer';\nexport declare type CfgParams = {\n    writer?: Writer;\n    decorator?: 'plain' | 'fancy' | HelpDecorator;\n};\nexport declare function configure<D extends CliDeclaration>(decl: D, params?: CfgParams): {\n    parse: (argv: string[] | string) => ResolveCliDeclaration<D>;\n    generateHelp: () => string;\n    params: {\n        writer: Writer;\n        decorator: HelpDecorator;\n    };\n};\nexport declare function cli<D extends CliDeclaration>(decl: D, params?: CfgParams): ResolveCliDeclaration<D>;\nexport declare function option<T extends Types>(type: T): Option<T, false, false, {\n    number: number;\n    int: number;\n    string: string;\n    boolean: boolean;\n    any: string | number | boolean;\n}[T]>;\n"},{"filename":"node_modules/@types/typed-cli/src/pipeline.d.ts","content":"export declare type Validator<T> = (value: T) => void;\nexport declare type BooleanValidator<T> = (value: T) => boolean;\nexport declare function makeValidator<T>(errorMsg: string, fn: (value: T) => boolean): Validator<T>;\nexport declare type Preprocessor<I = any, O = any> = (value: I) => O;\nexport declare type ValidationReport = {\n    isValid: boolean;\n    items: {\n        [key: string]: {\n            errors: string[];\n        };\n    };\n    warnings: string[];\n};\ninterface ValidationCfg {\n    isRequired: boolean;\n    validators: Validator<any>[];\n}\ninterface OptCfg extends ValidationCfg {\n    prePreprocessors: Preprocessor[];\n    postPreprocessors: Preprocessor[];\n    isArray: boolean;\n}\nexport declare function handleOption(optCfg: OptCfg, value: any, iterating?: boolean): {\n    value: any;\n    errors: string[];\n};\nexport declare function handleAllOptions(optSchema: Record<string, OptCfg>, rawData: Record<string, any>, usedKeys: Set<string>): {\n    data: any;\n    report: ValidationReport;\n};\nexport {};\n"},{"filename":"node_modules/@types/typed-cli/src/printer.d.ts","content":"import { ValidationReport } from './pipeline';\nimport { CliDeclaration } from './type-logic';\nexport declare function printOptionError(title: string, errors: string[], decorator: HelpDecorator, writer: Writer): void;\nexport declare function printArgumentError(errors: string[], decorator: HelpDecorator, writer: Writer): void;\nexport declare function printReport(report: ValidationReport, decorator: HelpDecorator, writer: Writer): void;\ndeclare type DecoratorCtx = 'alias' | 'type' | 'optionality' | 'option-description' | 'title' | 'usage-option' | 'command' | 'optionality-required' | 'optionality-multiple' | 'error' | 'warning';\nexport declare type Writer = (text: string) => void;\nexport declare type HelpDecorator = (text: string, ctx: DecoratorCtx) => string;\nexport declare const defaultHelpDecorator: (str: string) => string;\nexport declare const fancyHelpDecorator: HelpDecorator;\nexport declare function generateHelp(config: CliDeclaration, decorator?: HelpDecorator): string;\nexport {};\n"},{"filename":"node_modules/@types/typed-cli/src/type-logic.d.ts","content":"import { Option, OptionSet, Types } from './option';\nexport declare type GetPropertiyNames<T extends Object, P> = {\n    [K in keyof T]: T[K] extends P ? K : never;\n}[keyof T];\nexport declare type GetProperties<T extends Object, P> = Pick<T, GetPropertiyNames<T, P>>;\ndeclare type PickRequiredOpts<O extends OptionSet> = GetProperties<O, Option<any, true, boolean, any> | Option<any, boolean, true, any>>;\ndeclare type PickNonRequiredOpts<O extends OptionSet> = GetProperties<O, Option<any, false, boolean, any>>;\ndeclare type ResolveOptionType<O extends Option<Types, boolean, boolean, any>> = O extends Option<any, boolean, boolean, infer R> ? R : never;\ndeclare type ResolveOption<O extends Option<Types, boolean, boolean, any>> = O extends Option<Types, boolean, true, any> ? Array<ResolveOptionType<O>> : ResolveOptionType<O>;\ndeclare type ResolveOptionSet<O extends OptionSet> = {\n    [key in keyof PickRequiredOpts<O>]: ResolveOption<PickRequiredOpts<O>[key]>;\n} & {\n    [key in keyof PickNonRequiredOpts<O>]?: ResolveOption<PickNonRequiredOpts<O>[key]>;\n};\nexport declare type CliDeclaration = {\n    command?: string;\n    options?: OptionSet;\n    description?: string;\n    _?: Option<Types, boolean, boolean, any>;\n};\nexport declare type ResolveCliDeclaration<D extends CliDeclaration> = {\n    options: D['options'] extends OptionSet ? ResolveOptionSet<D['options']> : {};\n    _: D['_'] extends Option<any, infer R, any, any> ? R extends true ? ResolveOption<D['_']> : ResolveOption<D['_']> | undefined : undefined;\n};\nexport {};\n"},{"filename":"node_modules/@types/typed-cli/src/utils.d.ts","content":"export declare function createKebabAlias(str: string): string | undefined;\nexport declare function objMap<T, R>(obj: Record<string, T>, fn: (item: T) => R): Record<string, R>;\nexport declare function alignTextMatrix(textMatrix: string[][]): string[][];\nexport declare function arrayPartition<T>(array: T[], fn: (item: T, index: number, array: T[]) => boolean): [T[], T[]];\n"}];